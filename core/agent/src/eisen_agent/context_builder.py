"""Builds context for sub-agent prompts based on effort level.

Uses the PyO3 bridge (eisen_bridge) to extract workspace structure
and symbol information at different levels of detail.
"""

from __future__ import annotations

import json
import logging
import os
from typing import Any

import eisen_bridge

from eisen_agent.config import EffortLevel

logger = logging.getLogger(__name__)


class ContextBuilder:
    """Builds context for sub-agent prompts based on effort level.

    Effort levels control how much context is injected:
      - low:    No file listing, no cross-region deps, no step plan
      - medium: File listing + cross-region deps (from eisen_bridge)
      - high:   File listing + cross-region deps + step-by-step plan
    """

    def __init__(self, workspace: str):
        self._workspace = os.path.abspath(workspace)

    def build_region_context(self, region: str, effort: EffortLevel) -> dict[str, Any]:
        """Build context for a region at the given effort level.

        Returns:
          {
            "region_files": [...],       # files in region with line counts
            "cross_region_deps": [...],  # dependency signatures from outside region
            "step_plan": [...] | None,   # step-by-step plan (high effort only)
          }
        """
        if effort == EffortLevel.LOW:
            return {
                "region_files": [],
                "cross_region_deps": [],
                "step_plan": None,
            }

        # Medium and high: get file listing from snapshot
        region_files = self._get_region_files(region)
        cross_region_deps = self._get_cross_region_deps(region)

        return {
            "region_files": region_files,
            "cross_region_deps": cross_region_deps,
            "step_plan": None,  # High effort plan is generated by DSPy in orchestrator
        }

    def get_workspace_tree(self) -> str:
        """Get a compact directory listing of the workspace.

        Used as input to TaskDecompose for understanding workspace structure.
        """
        try:
            raw = eisen_bridge.parse_workspace(self._workspace)
            tree = json.loads(raw)
            return self._format_tree(tree)
        except Exception as e:
            logger.warning(f"Failed to parse workspace: {e}")
            return "(workspace parse failed)"

    def get_symbol_index(self) -> str:
        """Get top-level symbols per directory region.

        Used as input to TaskDecompose for understanding codebase symbols.
        """
        try:
            raw = eisen_bridge.snapshot(self._workspace)
            snapshot = json.loads(raw)
            return self._format_symbol_index(snapshot)
        except Exception as e:
            logger.warning(f"Failed to get snapshot: {e}")
            return "(symbol index failed)"

    def _get_region_files(self, region: str) -> list[dict[str, Any]]:
        """Get files in a region with basic metadata."""
        try:
            region_path = os.path.join(self._workspace, region.lstrip("/"))
            if not os.path.isdir(region_path):
                return []

            raw = eisen_bridge.snapshot(region_path)
            snapshot = json.loads(raw)
            files = []
            for path, node in snapshot.get("nodes", {}).items():
                if node.get("kind") == "file":
                    lines = node.get("lines", {})
                    files.append(
                        {
                            "path": path,
                            "lines": lines.get("end", 0) - lines.get("start", 0)
                            if lines
                            else 0,
                        }
                    )
            return files
        except Exception as e:
            logger.warning(f"Failed to get region files for {region}: {e}")
            return []

    def _get_cross_region_deps(self, region: str) -> list[str]:
        """Find symbols referenced from outside the region.

        This is a simplified version -- for now, returns an empty list.
        Full implementation would parse imports in the region files and
        look up their definitions via eisen_bridge.lookup_symbol().
        """
        # TODO: Implement cross-region dependency resolution
        # This would involve:
        # 1. Parse files in the region to extract import statements
        # 2. For each imported symbol, call eisen_bridge.lookup_symbol()
        # 3. Filter to symbols defined outside the region
        # 4. Return their signatures
        return []

    def _format_tree(self, tree: Any, indent: int = 0) -> str:
        """Format a nested JSON tree as a compact directory listing."""
        if not isinstance(tree, dict):
            return str(tree)

        lines = []
        prefix = "  " * indent
        name = tree.get("name", "")
        kind = tree.get("kind", "")

        if kind == "folder":
            lines.append(f"{prefix}{name}/")
        elif kind == "file":
            lines.append(f"{prefix}{name}")
        else:
            lines.append(f"{prefix}{name} ({kind})")

        for child in tree.get("children", []):
            lines.append(self._format_tree(child, indent + 1))

        return "\n".join(lines)

    def _format_symbol_index(self, snapshot: dict[str, Any]) -> str:
        """Format a UiSnapshot as a symbol index grouped by file."""
        lines = []
        nodes = snapshot.get("nodes", {})

        # Group symbols by file
        files: dict[str, list[str]] = {}
        for path, node in sorted(nodes.items()):
            kind = node.get("kind", "")
            if kind == "file":
                files.setdefault(path, [])
            elif "::" in path:
                file_path = path.split("::")[0]
                symbol_name = path.split("::")[-1]
                files.setdefault(file_path, []).append(f"  {kind}: {symbol_name}")

        for file_path, symbols in sorted(files.items()):
            lines.append(file_path)
            lines.extend(symbols)

        return "\n".join(lines) if lines else "(no symbols found)"
